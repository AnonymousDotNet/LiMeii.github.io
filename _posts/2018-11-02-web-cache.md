---
title: 浏览器缓存机制：强缓存和协商缓存
tags: web
layout: post
---

缓存算是性能优化中比较简单又高效的方式，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。这篇文件就来介绍强缓存和协商缓存的工作机制。

## 什么是浏览器缓存
以Chrome为例，打开DevTools到NetWork，第一次访问我的Github，能看到总共有28个HTTP Request都是从服务响应拿到的：
![web-cache](/assets/images/posts/web/web-cache01.png){:height="100%" width="100%"}

刷新页面，我们看到这个28个Request，有的是从```memory cache```和```disk cache```拿到的，有些是从服务器响应拿到的：
![web-cache](/assets/images/posts/web/web-cache02.png){:height="100%" width="100%"}

在上图中可以看到，浏览器把一些css文件和图片这些静态资源放在了```memory cache```和```disk cache```，后续在访问这个页面的时候，这些静态资源就可以直接从缓存里拿，而不需要去服务器上下载，从而可以提高性能。


整个流程如下：
![web-cache](/assets/images/posts/web/web-cache03.png){:height="100%" width="100%"}

### memory cache和disk cache的区别
静态资源文件，可以放在memory cache也可以放在disk cache里，那么这两个有什么区别呢？

**memory cache**

memory cache是内存中的缓存，主要包含当前页面中已经下载的资源，比如样式、脚本、图片等等。读取内存中的数据肯定比磁盘块，但是内存缓存的时间段，会随着进程的是否而释放。一旦我们关闭Tab页面，内存中的缓存就被释放了。


因为内存有限，并不是所有的资源文件都会放在内存里缓存，它主要用来缓存有preloader相关指令的资源，比如```<link rel="prefetch">```。preloader可以一边解析js/css文件，一边网络请求下一个资源。

**disk cache**

disk cache也就是存在磁盘上的缓存，读取速度比memory cache慢点，但是所有的资源文件都可以存在磁盘里。在所有浏览器缓存中，disk cache覆盖面最大，它会根据HTTP Header中的字段判断哪些资源需要缓存，哪些资源已经过期需要重新从服务器端请求。


一般来说，大的文件和使用频率高的文件，会被优先放在磁盘里。

## 那么浏览器怎么知道要缓存哪些文件？
从服务器返回的Http Response Header中，通常有这几个属性用来标识缓存：
- Cache-Control
- Expires
- ETag / If-None-Match
- Last-Modified / If-Modified-Since

其中Expires和Cache-Control是用来标识强缓存，ETag和Last-Modified用来标识协商缓存。


### 强缓存
强缓存是不会向服务器发送请求，直接从缓存中读取资源，在DevTools的Network可以看到该请求的状态码是200，并且在Size那一列里会显示from memory cache或者from disk cache。强缓存是通过Expires和Cache-Control来实现的，如下：
![web-cache](/assets/images/posts/web/web-cache04.png){:height="100%" width="100%"}

**Expires**

```html
Expires: Wed, 25 Sep 2019 08:13:53 GMT
```
这个属性是http1.0里的，表示缓存里的文件在这个属性对应时间以后过期。在HTTP Response时告诉浏览器在过期时间内可以直接从浏览器缓存里读取数据，无需再次请求，```Expires: Wed, 25 Sep 2019 08:13:53 GMT```表示资源会在```Expires: Wed, 25 Sep 2019 08:13:53 GMT```后过期，需要再次请求。


Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

**Cache-Control**

Cache-Control是HTTP/1.1的产物，同时有Expires和Cache-Control的时候，Cache-Control的优先级要比Expires要高，比如```Cache-Control: max-age=300```，表示这个请求的返回时间（浏览器会记录该时间）的五分钟之内再次加载该资源，就会从缓存中读取该文件，无需再次请求。


Cache-Control除了max-age之外，还有好几个属性可以用来控制cache的行为，比如：

```html
Cache-Control: public
```
public 表示资源可以被缓存在任何可以被缓存的地方（CDN，中间代理服务器，浏览器等等），可以多用户共享

```html
Cache-Control: private
```
private 表示资源只可以被浏览器缓存，是私有缓存

```html
Cache-Control: no-store
```
no-store表示浏览器需要每次都从服务器拿资源，真正的不缓存数据到本地。

```html
Cache-Control: no-cache
```
no-cache并不是不缓存的意思，而是告诉浏览器要使用缓存文件，但是每次需要跟服务器确认是最新文件以后才能用，一般使用Etag或者Last-Modified字段来控制缓存，看Etag/Last-Modified是否跟服务器匹配，如果匹配就返回304告诉浏览器从缓存里取数据，不匹配就返回200并且重新返回数据。

```html
Cache-Control: max-age=60
```
表示资源文件缓存的相对时间，这个请求的返回时间（浏览器会记录该时间）的1分钟之内再次加载该资源，就会从缓存中读取该文件，无需再次请求。

```html
Cache-Control: s-maxage=60
```
覆盖max-age，作用一样，只在代理服务器中生效

```html
Cache-Control: must-revalidate
```
表示只有校验缓存里是最新文件才能用缓存里的版本

```html
Cache-Control: max-stale=30
```
能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）

```html
Cache-Control: max-fresh=30
```
能够容忍的最小新鲜度，min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应

如何结合使用上面这些Cache-Control的属性，可以参考如下：
![web-cache](/assets/images/posts/web/web-cache05.png){:height="100%" width="100%"}

### 协商缓存
协商缓存是指在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存，过程如下：
- 缓存还有效，返回304和Not Modified
![web-cache](/assets/images/posts/web/web-cache06.png){:height="100%" width="100%"}

- 缓存失效，返回200和请求结果
![web-cache](/assets/images/posts/web/web-cache07.png){:height="100%" width="100%"}

协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的，如下：
![web-cache](/assets/images/posts/web/web-cache08.png){:height="100%" width="100%"}

**Last-Modified**

浏览器第一次访问资源，服务器会Response Header里添加Last-Modified的值，表示这个资源在服务器的最后修改时间，浏览器在下一次请求这个资源的时候，检测到有Last-Modified这个Header，就会在Request中加上If-Modified-Since，If-Modified-Since的值就是Last-Modified的值。服务器收到这个请求，会对比If-Modified-Since和服务器上这个资源的最后修改时间，如果一致就返回304和空的响应体，让浏览器直接从缓存里读取；如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。


但是Last-Modified有两个弊端：
- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

所以在HTTP/1.1里有了ETag和If-None-Match。

**ETag**

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

ETag的优先级要高于Last-Modified。


## 缓存机制总结
强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下：
![web-cache](/assets/images/posts/web/web-cache09.png){:height="100%" width="100%"}

### 如果浏览器没有设置缓存策略，缓存怎么处理？

缓存时间= (Response Date - Last Modified) % 10

## 用户行为对浏览器缓存的影响

所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。

参考文章：【[深入理解浏览器的缓存机制](https://github.com/ljianshu/Blog/issues/23)】